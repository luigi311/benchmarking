import csv
from datetime import datetime, timedelta
from models import Result
from sqlalchemy.exc import SQLAlchemyError


# parse_presetmon reads a CSV file and inserts rows into Result table
# session: SQLAlchemy Session
# filepath: path to CSV generated by PresentMon
# CSV columns can contain 'NA'; converts them to None

# Base timestamp: Jan 1, 2000 00:00:00
BASE_TIMESTAMP = datetime(2000, 1, 1)

def parse_presetmon(session, filepath, run_id):
    """
    Read CSV at `filepath`, map each row to a Result, set run_id,
    convert 'NA' to None to avoid type errors, and add to the session.
    Skips rows with duplicate (run_id, sample_time_ms) to avoid key errors.
    Returns session without committing.
    """
    def parse_field(row, key, caster):
        raw = row.get(key)
        if raw is None or raw.upper() == 'NA' or raw == '':
            return None
        try:
            return caster(float(raw))
        except ValueError:
            return None

    def parse_sample_time_ms(row):
        raw = row.get('CPUStartTime')
        if raw is None or raw.upper() == 'NA' or raw == '':
            return None
        try:
            return int(float(raw) * 1000)
        except ValueError:
            return None

    with open(filepath, newline='') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            sample_time_ms = parse_sample_time_ms(row)
            if sample_time_ms is None:
                continue
            # skip duplicates
            exists = session.query(Result).filter_by(
                run_id=run_id,
                sample_time_ms=sample_time_ms
            ).first()
            if exists:
                continue

            timestamp = BASE_TIMESTAMP + timedelta(milliseconds=sample_time_ms)

            data = {
                'run_id': run_id,
                'sample_time_ms': sample_time_ms,
                'time_stamped': timestamp,
                'frame_time': parse_field(row, 'FrameTime', float),
                'cpu_busy': parse_field(row, 'CPUBusy', float),
                'cpu_wait': parse_field(row, 'CPUWait', float),
                'gpu_latency': parse_field(row, 'GPULatency', float),
                'gpu_time': parse_field(row, 'GPUTime', float),
                'gpu_busy': parse_field(row, 'GPUBusy', float),
                'gpu_wait': parse_field(row, 'GPUWait', float),
                'display_latency': parse_field(row, 'DisplayLatency', float),
                'gpu_power': parse_field(row, 'GPUPower', float),
                'gpu_voltage': parse_field(row, 'GPUVoltage', float),
                'gpu_frequency': parse_field(row, 'GPUFrequency', float),
                'gpu_temperature': parse_field(row, 'GPUTemperature', float),
                'gpu_utilization': parse_field(row, 'GPUUtilization', float),
                'gpu_memory_frequency': parse_field(row, 'GPUMemoryFrequency', float),
                'gpu_memory_size_used': parse_field(row, 'GPUMemorySizeUsed', int),
                'gpu_fan_speed_0': parse_field(row, 'GPUFanSpeed[0]', int),
                'gpu_fan_speed_1': parse_field(row, 'GPUFanSpeed[1]', int),
                'gpu_fan_speed_2': parse_field(row, 'GPUFanSpeed[2]', int),
                'gpu_fan_speed_3': parse_field(row, 'GPUFanSpeed[3]', int),
                'cpu_utilization': parse_field(row, 'CPUUtilization', float),
                'cpu_power': parse_field(row, 'CPUPower', float),
                'cpu_temperature': parse_field(row, 'CPUTemperature', float),
                'cpu_frequency': parse_field(row, 'CPUFrequency', float),
            }
            try:
                session.add(Result(**data))
            except SQLAlchemyError:
                # skip invalid rows
                print(f"Invalid row for {data['sample_time_ms']}")
                session.rollback()
                continue
    return session
